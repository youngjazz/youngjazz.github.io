<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="什么是Classloader一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。 什么时候加载？  new 操作 Class.forName(“包路径+类名”) Class.forName(“包路径+类名”, classloader)">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="ClassLoader揭秘">
<meta property="og:url" content="http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/index.html">
<meta property="og:site_name" content="Leon&#39; Blog">
<meta property="og:description" content="什么是Classloader一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。 什么时候加载？  new 操作 Class.forName(“包路径+类名”) Class.forName(“包路径+类名”, classloader)">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://p7b5cwgjy.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%81%94%E7%B3%BB">
<meta property="og:updated_time" content="2019-03-26T09:31:09.571Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ClassLoader揭秘">
<meta name="twitter:description" content="什么是Classloader一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。 什么时候加载？  new 操作 Class.forName(“包路径+类名”) Class.forName(“包路径+类名”, classloader)">
<meta name="twitter:image" content="http://p7b5cwgjy.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%81%94%E7%B3%BB">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>ClassLoader揭秘</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/09/24/RabbitMQ/MQ/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/08/15/缓存/缓存三大问题及解决方案/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&text=ClassLoader揭秘"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&is_video=false&description=ClassLoader揭秘"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ClassLoader揭秘&body=Check out this article: http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&name=ClassLoader揭秘&description=&lt;h2 id=&#34;什么是Classloader&#34;&gt;&lt;a href=&#34;#什么是Classloader&#34; class=&#34;headerlink&#34; title=&#34;什么是Classloader&#34;&gt;&lt;/a&gt;什么是Classloader&lt;/h2&gt;&lt;p&gt;一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。&lt;/p&gt;
&lt;p&gt;什么时候加载？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new 操作&lt;/li&gt;
&lt;li&gt;Class.forName(“包路径+类名”)&lt;/li&gt;
&lt;li&gt;Class.forName(“包路径+类名”, classloader)&lt;/li&gt;
&lt;li&gt;classloader.loadclass(“包路径+类名”)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上操作会触发类加载器去加载对应的路径去查找*.class, 并创建Class对象。&lt;/p&gt;"><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Classloader"><span class="toc-number">1.</span> <span class="toc-text">什么是Classloader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java自带的Classloader"><span class="toc-number">2.</span> <span class="toc-text">Java自带的Classloader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BootstrapClassLoader"><span class="toc-number">2.1.</span> <span class="toc-text">BootstrapClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtClassLoader"><span class="toc-number">2.2.</span> <span class="toc-text">ExtClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppClassLoader"><span class="toc-number">2.3.</span> <span class="toc-text">AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种加载器的联系"><span class="toc-number">2.4.</span> <span class="toc-text">三种加载器的联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的原理"><span class="toc-number">2.5.</span> <span class="toc-text">类加载器的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何构造三种类加载器的结构"><span class="toc-number">2.6.</span> <span class="toc-text">如何构造三种类加载器的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一种特殊的类加载器-ContextClassLoader"><span class="toc-number">3.</span> <span class="toc-text">一种特殊的类加载器 ContextClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat-ClassLoader"><span class="toc-number">4.</span> <span class="toc-text">Tomcat ClassLoader</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        ClassLoader揭秘
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Leon' Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-09-17T06:38:16.000Z" itemprop="datePublished">2018-09-17</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JVM/">JVM</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="什么是Classloader"><a href="#什么是Classloader" class="headerlink" title="什么是Classloader"></a>什么是Classloader</h2><p>一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。</p>
<p>什么时候加载？</p>
<ul>
<li>new 操作</li>
<li>Class.forName(“包路径+类名”)</li>
<li>Class.forName(“包路径+类名”, classloader)</li>
<li>classloader.loadclass(“包路径+类名”)</li>
</ul>
<p>以上操作会触发类加载器去加载对应的路径去查找*.class, 并创建Class对象。</p>
<a id="more"></a>
<h2 id="Java自带的Classloader"><a href="#Java自带的Classloader" class="headerlink" title="Java自带的Classloader"></a>Java自带的Classloader</h2><h3 id="BootstrapClassLoader"><a href="#BootstrapClassLoader" class="headerlink" title="BootstrapClassLoader"></a>BootstrapClassLoader</h3><p>引导类加载器，又称启动类加载器，是最顶层的加载器，主要用来加载Java核心类，比如resouce.jar, rt.jar, charset.jar等，Sun的JVM中，执行java的命令使用-Xbootclasspath选项或是用-D选项指定sun.boot.class.path系统属性值可以指定附加的类，他不是java.lang.ClassLoader的子类，而是JVM自身实现的该类C语言实现，Java程序访问不到该加载器。通过下面代码可以查看该加载器加载了哪些jar包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">    Arrays.stream(urLs).forEach(System.out::println);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/classes</span><br></pre></td></tr></table></figure>
<p>我们并没有在classpath里面指定这些类的路径，为什么还是能够加载到jvm中的，因为这是bootstrap来加载的。</p>
<h3 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h3><p>扩展类加载器，主要负责加载java扩展类。默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar或者由java.ext.dirs系统属性指定的jar包。放入这个目录下的jar对所有AppClassLoader可见（后面会知道ExtClassLoader是APPClassLoader的父类加载器）。那么ExtClassLoader在哪些地方加载类呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/leon/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br></pre></td></tr></table></figure>
<h3 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h3><p>系统类加载器，又称应用类加载器。它负责在JVM启动时加载来自命令中-classpath或者java.class.path系统属性或者CLASSPATH操作系统属性指定的jar类包和类路径。调用ClassLoader.getSystemClassLoader()可以获取类加载器，如果没有特别指定，用户自定义的任何类加载器都将该类加载器作为他的父加载器，通过调用ClassLoader的无参构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下代码可以获得classpath的加载路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(System.getProperty(<span class="string">"java.class.path"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="三种加载器的联系"><a href="#三种加载器的联系" class="headerlink" title="三种加载器的联系"></a>三种加载器的联系</h3><p><img src="http://p7b5cwgjy.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%81%94%E7%B3%BB" alt="三种加载器联系"></p>
<p>用户自定义的无参构造器的父类加载器是默认的AppCLassLoader加载器，而AppClassLoader的父类加载器是ExtClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLoader.getSystemClassLoader().);</span><br><span class="line">ClassLoader parent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">System.out.println(parent);</span><br><span class="line">System.out.println(parent.getParent());</span><br></pre></td></tr></table></figure>
<p>一般我们任务ExrClassloader的父类加载器是BootStrapClassLoader，但是它们之间并没有父子关系，只是在ExtClassLoader找不到要加载类时候回去委派BootStrap加载器去加载。上面的第四行代码打印出的就是null。</p>
<h3 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h3><p>Java类的加载器使用的是委托机制，也就是子类加载器在加载一个类时会让其父类加载，为什么使用这种方式？因为这样可以避免重复加载，当父类加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替换Java核心api中定义的类型，这样会存在很大的安全隐患。双亲委派可以避免这种情况，因为String已经在启动时就被引导类（Bootstrap ClassLoader）加载，所以用户自定义的ClassLoader永远无法加载一个自己写的String，除非你改变了JDK中ClassLoader搜索类的默认算法。从源码中我们可以看出如何实现委派机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分析源码我们知道，首先从JVM缓存总查找类，如果已经加载过，直接从JVM缓存返回，否则看当前类加载器是否有父加载器，如果有则委托父加载器去加载，如果没有父加载器就委托BootstrapClassloader去加载，如果还没有找到，这才调用当前classLoader类的findClass方法。<strong>自己实现的载入策略需要覆盖ClassLoader的findClass方法或覆盖loadClass方法来实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the class with the specified &lt;a href="#name"&gt;binary name&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     * This method should be overridden by class loader implementations that</span></span><br><span class="line"><span class="comment">     * follow the delegation model for loading classes, and will be invoked by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span></span><br><span class="line"><span class="comment">     * parent class loader for the requested class.  The default implementation</span></span><br><span class="line"><span class="comment">     * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment">     *         The &lt;a href="#name"&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment">     *          If the class could not be found</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何构造三种类加载器的结构"><a href="#如何构造三种类加载器的结构" class="headerlink" title="如何构造三种类加载器的结构"></a>如何构造三种类加载器的结构</h3><p>下面从源码来分析JVM如何构建内置classloader的，具体rt.jar 包里面sum.misc.Launcher类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ExtClassLoader localExtClassLoader;  </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;  <span class="comment">//首先创建了ExtClassLoader</span></span><br><span class="line">          localExtClassLoader = ExtClassLoader.getExtClassLoader();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (IOException localIOException1)  </span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;  <span class="comment">//然后以ExtClassloader作为父加载器创建了AppClassLoader</span></span><br><span class="line">          <span class="keyword">this</span>.loader = AppClassLoader.getAppClassLoader(localExtClassLoader);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (IOException localIOException2)  </span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>);  </span><br><span class="line">        &#125;  <span class="comment">//这个是个特殊的加载器后面会讲到，这里只需要知道默认下线程上下文加载器为appclassloader</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);  </span><br><span class="line"> </span><br><span class="line">        ................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看下ExtClassLoader.getExtClassLoader()的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> File[] var0 = getExtDirs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> var1 = var0.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">                    MetaIndex.registerDirectory(var0[var2]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)var2.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getExtDirs() 是使用了System.getProperty(“java.ext.dirs”)</p>
<p>AppClassLoader.getAppClassLoader的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//AppClassLoader加载路径为java.class.path</span></span><br><span class="line">    <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下，Java应用启动过程首先是BootstrapClassLoader加载rt.jar里面的Launcher类，而该类内不是用BootstrapClassloader加载器构建和初始化Java中三类加载和线程上下文加载器，然后根据不同的 场景使用这些加载器去自己的类查找路径去加载类。</p>
<h2 id="一种特殊的类加载器-ContextClassLoader"><a href="#一种特殊的类加载器-ContextClassLoader" class="headerlink" title="一种特殊的类加载器 ContextClassLoader"></a>一种特殊的类加载器 ContextClassLoader</h2><p>阅读过tomcat源码的话对于ContextClassLoader一定很熟悉的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前线程上下文类加载器</span></span><br><span class="line">ClassLoader classloader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(targetTcc1);</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//设置当前线程上下文类加载器为原始类加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(classloader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doSomething 里面调用的是Thread.currentThread().getContextClassLoader()获取当前线程上下文类加载器来做些事情。这其中的奥秘和使用场景是什么？</p>
<p>我们知道java默认的类加载机制是委托机制，但是这种加载顺序<strong>有时不能正常工作</strong>，通常发生在有些JVM核心代码需要动态加载有程序开发者提供的资源时。以JNDI为例，它的核心内容和接口在rt.jar中引导类中实现了，但是这些JNDI可能会加载由独立厂商实现和部署在classpath的JNDI提供者。<strong>这个场景要求一个父类加载器去加载一个他的子类加载器中可见的类</strong>。这个例子中父类加载器指的是加载rt.jar的bootstrap加载器，子类加载器为AppClassLoader。此时通常的J2SE<strong>委托机制就不能胜任</strong>了。解决办法是让JNDI核心使用线程上下文加载器（默认线程上下文加载器为AppCLassLoader）</p>
<h2 id="Tomcat-ClassLoader"><a href="#Tomcat-ClassLoader" class="headerlink" title="Tomcat ClassLoader"></a>Tomcat ClassLoader</h2>
  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Classloader"><span class="toc-number">1.</span> <span class="toc-text">什么是Classloader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java自带的Classloader"><span class="toc-number">2.</span> <span class="toc-text">Java自带的Classloader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BootstrapClassLoader"><span class="toc-number">2.1.</span> <span class="toc-text">BootstrapClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtClassLoader"><span class="toc-number">2.2.</span> <span class="toc-text">ExtClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppClassLoader"><span class="toc-number">2.3.</span> <span class="toc-text">AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种加载器的联系"><span class="toc-number">2.4.</span> <span class="toc-text">三种加载器的联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的原理"><span class="toc-number">2.5.</span> <span class="toc-text">类加载器的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何构造三种类加载器的结构"><span class="toc-number">2.6.</span> <span class="toc-text">如何构造三种类加载器的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一种特殊的类加载器-ContextClassLoader"><span class="toc-number">3.</span> <span class="toc-text">一种特殊的类加载器 ContextClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat-ClassLoader"><span class="toc-number">4.</span> <span class="toc-text">Tomcat ClassLoader</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&text=ClassLoader揭秘"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&is_video=false&description=ClassLoader揭秘"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ClassLoader揭秘&body=Check out this article: http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&title=ClassLoader揭秘"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/09/17/JVM/ClassLoader揭秘/&name=ClassLoader揭秘&description=&lt;h2 id=&#34;什么是Classloader&#34;&gt;&lt;a href=&#34;#什么是Classloader&#34; class=&#34;headerlink&#34; title=&#34;什么是Classloader&#34;&gt;&lt;/a&gt;什么是Classloader&lt;/h2&gt;&lt;p&gt;一个Java程序要想运行起来，首先需要经过编译成.class文件，然后创建一个环境（JVM）来加载字节码文件到内存中运行，而.class文件是怎么加载到JVM中去的呢？这就是Java Classloader做的事情了。&lt;/p&gt;
&lt;p&gt;什么时候加载？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new 操作&lt;/li&gt;
&lt;li&gt;Class.forName(“包路径+类名”)&lt;/li&gt;
&lt;li&gt;Class.forName(“包路径+类名”, classloader)&lt;/li&gt;
&lt;li&gt;classloader.loadclass(“包路径+类名”)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上操作会触发类加载器去加载对应的路径去查找*.class, 并创建Class对象。&lt;/p&gt;"><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 leon
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



